package org.apache.giraph.yarn;

import com.google.common.base.Strings;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.*;
import org.apache.hadoop.security.UserGroupInformation;
import org.apache.hadoop.yarn.api.ApplicationConstants;
import org.apache.hadoop.yarn.api.records.*;
import org.apache.hadoop.yarn.util.Apps;
import org.apache.hadoop.yarn.util.ConverterUtils;
import org.apache.hadoop.yarn.util.Records;

import java.io.*;
import java.util.*;

/**
 * Created by IntelliJ IDEA.
 * User: dcapwell
 * Date: 11/10/11
 * Time: 6:39:12AM
 * To change this template use File | Settings | File Templates.
 */
public class Util {
    private static final Log LOG = LogFactory.getLog(Util.class.getName());

    /**
     * Get the jar File path for the given class.  If the class is not jared, but in a .class file, this method
     * will return the directory containing the class
     */
    public static File getJarPath(Class jarClass) {
        return new File(jarClass.getProtectionDomain().getCodeSource().getLocation().getPath());
    }

    public static int getMemorySize(int desired, int minMem, int maxMem) {
        // A resource ask has to be atleast the minimum of the capability of the cluster, the value has to be
        // a multiple of the min value and cannot exceed the max.
        // If it is not an exact multiple of min, the RM will allocate to the nearest multiple of min
        if (desired < minMem) {
            LOG.info("Container memory specified below min threshold of cluster. Using min value."
                    + ", specified=" + desired
                    + ", min=" + minMem);
            desired = minMem;
        } else if (desired > maxMem) {
            LOG.info("Container memory specified above max threshold of cluster. Using max value."
                    + ", specified=" + desired
                    + ", max=" + maxMem);
            desired = maxMem;
        }
        return desired;
    }

    public static void setupContainerCommand(ContainerLaunchContext amContainer, Class containerClass) {
        // Set the necessary command to execute the application master
        Vector<CharSequence> vargs = new Vector<CharSequence>(30);

        // Set java executable command
        LOG.info("Setting up app master command");
        vargs.add(ApplicationConstants.Environment.JAVA_HOME.$() + "/bin/java");

        // Set class name
        vargs.add(containerClass.getName());

        vargs.add("1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/stdout");
        vargs.add("2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/stderr");

        // Get final commmand
        StringBuilder command = new StringBuilder();
        for (CharSequence str : vargs) {
            command.append(str).append(" ");
        }

        LOG.info("Completed setting up app master command " + command.toString());
        List<String> commands = new ArrayList<String>();
        commands.add(command.toString());
        amContainer.setCommands(commands);

        // Set the env variables to be setup in the env where the application master will be run
        LOG.info("Set the environment for the application master");
        Map<String, String> env = new HashMap<String, String>();

        // Add job.jar location to classpath
        Apps.addToEnvironment(env,
                ApplicationConstants.Environment.CLASSPATH.name(),
                ApplicationConstants.Environment.PWD.$() + Path.SEPARATOR + "job.jar");
        Apps.addToEnvironment(env,
                ApplicationConstants.Environment.CLASSPATH.name(),
                ApplicationConstants.Environment.PWD.$() + Path.SEPARATOR + "*");

        // Add standard Hadoop classes
          for (String c : ApplicationConstants.APPLICATION_CLASSPATH) {
            Apps.addToEnvironment(env, ApplicationConstants.Environment.CLASSPATH.name(), c);
          }

        // for mini yarn cluster, the above application_classpath will not work, so need autogenerated
        // add the runtime classpath needed for tests to work
        String testRuntimeClassPath = getTestRuntimeClasspath();
        if(!Strings.isNullOrEmpty(testRuntimeClassPath)) {
            Apps.addToEnvironment(env,
                ApplicationConstants.Environment.CLASSPATH.name(),
                testRuntimeClassPath);
        }

        amContainer.setEnvironment(env);
    }

    private static String getTestRuntimeClasspath() {

    InputStream classpathFileStream = null;
    BufferedReader reader = null;
    String envClassPath = "";

    LOG.info("Trying to generate classpath for app master from current thread's classpath");
    try {

      // Create classpath from generated classpath
      // Check maven pom.xml for generated classpath info
      // Works if compile time env is same as runtime. Mainly tests.
      ClassLoader thisClassLoader =
          Thread.currentThread().getContextClassLoader();
      String generatedClasspathFile = "giraph-yarn-app-generated-classpath";
      classpathFileStream =
          thisClassLoader.getResourceAsStream(generatedClasspathFile);
      if (classpathFileStream == null) {
        LOG.info("Could not classpath resource from class loader");
        return envClassPath;
      }
      LOG.info("Readable bytes from stream=" + classpathFileStream.available());
      reader = new BufferedReader(new InputStreamReader(classpathFileStream));
      String cp = reader.readLine();
      if (cp != null) {
        envClassPath += cp.trim() + ":";
      }
      // Put the file itself on classpath for tasks.
      envClassPath += thisClassLoader.getResource(generatedClasspathFile).getFile();
    } catch (IOException e) {
      LOG.info("Could not find the necessary resource to generate class path for tests. Error=" + e.getMessage());
    }

    try {
      if (classpathFileStream != null) {
        classpathFileStream.close();
      }
      if (reader != null) {
        reader.close();
      }
    } catch (IOException e) {
      LOG.info("Failed to close class path file stream or reader. Error=" + e.getMessage());
    }
    return envClassPath;
  }

    static LocalResource getDefaultLocalResource() {
        LocalResource localResource = Records.newRecord(LocalResource.class);

        // Set the type of resource - file or archive
        // archives are untarred at destination
        // we don't need the jar file to be untarred for now
        localResource.setType(LocalResourceType.FILE);
        // Set visibility of the resource
        // Setting to most private option
        localResource.setVisibility(LocalResourceVisibility.APPLICATION);

        return localResource;
    }

    public static Path getStagingDir(Configuration conf, ApplicationId appId) throws IOException {
        Path stagingRootDir = new Path(conf.get("giraph.yarn.job.staging.root.dir", "/tmp/hadoop/giraph/staging"));
        UserGroupInformation ugi = UserGroupInformation.getCurrentUser();
        String user;
        if(ugi == null) {
            user = "dummy-yarn-user";
        } else {
            user = ugi.getShortUserName();
        }
        stagingRootDir = new Path(stagingRootDir, user + Path.SEPARATOR_CHAR + ".staging");

        FileSystem fs = FileSystem.get(conf);
        return fs.makeQualified(new Path(stagingRootDir, appId.toString()));
    }

    public static void addPathContentAsResource(FileSystem fs, Path path, Map<String, LocalResource> localResources) throws IOException {
        FileStatus[] children = fs.listStatus(path);
        if(children != null) {
            for(FileStatus child : children) {
                LOG.info("Adding Path " + child.getPath() + " as a LocalResource ("+child.getPath().getName()+")");
                // hdfs://localhost:57005/tmp/hadoop/giraph/staging/dcapwell/.staging/application_1321078233806_0001/job.jar
                LocalResource localResource = Util.getDefaultLocalResource();
                // Set the resource to be copied over
                localResource.setResource(ConverterUtils.getYarnUrlFromPath(child.getPath()));
                // Set timestamp and length of file so that the framework
                // can do basic sanity checks for the local resource
                // after it has been copied over to ensure it is the same
                // resource the client intended to use with the application
                localResource.setTimestamp(child.getModificationTime());
                localResource.setSize(child.getLen());

                localResources.put(child.getPath().getName(), localResource);
            }
        }
    }
}
